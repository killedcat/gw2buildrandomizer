<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GW2 Random Build Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --bg: #1a1b26;
            --panel: #24283b;
            --muted: #9aa5ce;
            --text: #c0caf5;
            --accent: #7aa2f7;
            --border: #414868;
            --success: #9ece6a;
            --warning: #e0af68;
            --error: #f7768e;
        }
        html, body { height: 100%; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            background: linear-gradient(135deg, var(--bg) 0%, #2d3748 100%); 
            color: var(--text);
            line-height: 1.6;
        }
        .container { max-width: 980px; margin: 0 auto; padding: 24px; }
        h1 { 
            font-size: 28px; 
            font-weight: 700; 
            margin: 0 0 16px; 
            background: linear-gradient(45deg, var(--accent), #bb9af7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }
        .title { font-size: 24px; font-weight: 600; letter-spacing: 0.2px; margin: 0 0 8px; color: var(--text); }
        .controls { 
            display: flex; 
            gap: 16px; 
            align-items: flex-end; 
            flex-wrap: wrap; 
            margin-bottom: 24px;
            justify-content: center;
            padding: 20px;
            background: rgba(36, 40, 59, 0.8);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(65, 72, 104, 0.3);
        }
        .controls label { 
            font-size: 14px; 
            color: var(--muted); 
            display: flex; 
            flex-direction: column; 
            gap: 8px;
            font-weight: 500;
        }
        select, input { 
            background: rgba(26, 27, 38, 0.8); 
            color: var(--text); 
            border: 2px solid var(--border); 
            border-radius: 12px; 
            padding: 12px 16px; 
            min-width: 160px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(122, 162, 247, 0.2);
        }
        button.primary { 
            background: linear-gradient(45deg, var(--accent), #bb9af7); 
            color: white; 
            border: 0; 
            border-radius: 12px; 
            padding: 12px 20px; 
            font-weight: 600; 
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(122, 162, 247, 0.3);
        }
        button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(122, 162, 247, 0.4);
        }
        button.ghost { 
            background: rgba(36, 40, 59, 0.6); 
            border: 2px solid var(--border); 
            color: var(--text); 
            border-radius: 12px; 
            padding: 10px 16px; 
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        button.ghost:hover {
            background: rgba(36, 40, 59, 0.8);
            border-color: var(--accent);
            transform: translateY(-1px);
        }
                 .card { 
             background: rgba(36, 40, 59, 0.9); 
             border: 1px solid var(--border); 
             border-radius: 20px; 
             padding: 24px;
             backdrop-filter: blur(10px);
             box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
             width: 600px;
         }
        .row { display: flex; align-items: center; gap: 12px; }
        .between { justify-content: space-between; }
        .skillbar { 
            display: grid; 
            grid-template-columns: repeat(5, 64px); 
            gap: 12px; 
            align-items: center;
            margin: 20px 0;
        }
        .skill { 
            width: 64px; 
            height: 64px; 
            border-radius: 16px; 
            background: rgba(26, 27, 38, 0.8); 
            border: 2px solid var(--border); 
            display: grid; 
            place-items: center; 
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .skill:hover {
            transform: scale(1.05);
            border-color: var(--accent);
            box-shadow: 0 4px 15px rgba(122, 162, 247, 0.3);
        }
        .skill img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .skill[title=""] { opacity: 0.45; }
        .meta { color: var(--muted); font-size: 14px; font-weight: 500; }
        .stack { display: grid; gap: 12px; }
                 .grid { display: grid; gap: 20px; grid-template-columns: 1fr; justify-items: center; }
        .copy { 
            display: inline-flex; 
            align-items: center; 
            gap: 8px; 
            background: rgba(26, 27, 38, 0.8); 
            border: 2px solid var(--border); 
            padding: 10px 14px; 
            border-radius: 12px; 
            font-family: 'Courier New', monospace;
            font-size: 13px;
            transition: all 0.3s ease;
        }
        .copy:hover {
            border-color: var(--success);
            background: rgba(158, 206, 106, 0.1);
        }
        .debug { margin-top: 16px; }
        .specs { display: grid; gap: 12px; }
                 .spec { 
             display: flex; 
             flex-direction: column;
             gap: 12px; 
             padding: 12px;
             background: rgba(26, 27, 38, 0.5);
             border-radius: 12px;
             border: 1px solid rgba(65, 72, 104, 0.3);
         }
         
         .spec-header {
             display: flex;
             align-items: center;
             gap: 12px;
         }
                 .spec .name { font-size: 18px; font-weight: 600; color: var(--text); }
        .traits { display: inline-grid; grid-auto-flow: column; gap: 6px; }
        .trait { width: 22px; height: 22px; border-radius: 6px; background: #0e141b; border: 1px solid var(--border); display: grid; place-items: center; font-size: 12px; color: var(--muted); overflow: hidden; }
        .weapons { display: grid; gap: 12px; align-items: center; }
        .weapon { 
            display: inline-flex; 
            align-items: center; 
            gap: 12px; 
            padding: 10px 14px; 
            border: 2px solid var(--border); 
            border-radius: 12px; 
            background: rgba(26, 27, 38, 0.6); 
            font-size: 13px; 
            color: var(--muted); 
            white-space: nowrap;
            transition: all 0.3s ease;
        }
        .weapon:hover {
            border-color: var(--warning);
            background: rgba(224, 175, 104, 0.1);
        }
        .sigils { display: inline-flex; gap: 8px; }
        .sigil { 
            display: inline-flex; 
            align-items: center; 
            gap: 6px; 
            font-size: 12px; 
            color: var(--muted);
            padding: 4px 8px;
            background: rgba(26, 27, 38, 0.8);
            border-radius: 8px;
        }
        .sigil img { width: 20px; height: 20px; border-radius: 6px; }
                 .traits-grid { display: grid; gap: 6px; margin-top: 8px; }
        .traits-row { display: grid; grid-template-columns: repeat(3, 24px); gap: 12px; align-items: center; }
        .cell { 
            width: 24px; 
            height: 24px; 
            border-radius: 8px; 
            border: 2px solid var(--border); 
            background: rgba(26, 27, 38, 0.8); 
            display: grid; 
            place-items: center; 
            overflow: visible; /* Changed from hidden to visible so tooltip can show */
            transition: all 0.3s ease;
            position: relative;
        }
        .cell:hover {
            transform: scale(1.1);
        }
        
        /* Override hover effect for cells with tooltips to avoid conflicts */
        .cell[data-tooltip]:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(122, 162, 247, 0.3);
        }
        .cell img { width: 24px; height: 24px; display: block; }
        .cell.off img { filter: grayscale(100%); opacity: 0.35; }
        .cell.on { 
            outline: 2px solid var(--accent); 
            outline-offset: -2px;
            box-shadow: 0 0 10px rgba(122, 162, 247, 0.4);
        }
        .hidden { display: none; }
        
        /* Custom tooltip styling - now handled by JavaScript */
        .cell[data-tooltip] {
            position: relative;
        }
        
        /* Test tooltip for button */
        button[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(36, 40, 59, 0.98), rgba(26, 27, 38, 0.98));
            color: var(--text);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            border: 1px solid rgba(122, 162, 247, 0.3);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            pointer-events: none;
            margin-bottom: 8px;
            white-space: nowrap;
        }
        
        button[data-tooltip] {
            position: relative;
        }
        

        
        /* Cute animations */
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(122, 162, 247, 0.3); }
            50% { box-shadow: 0 0 20px rgba(122, 162, 247, 0.6); }
        }
        
        .card {
            animation: glow 3s ease-in-out infinite;
        }
        
        @media (min-width: 880px) { .grid { grid-template-columns: 1fr 320px; } }
    </style>
    <script>
        async function loadProfessions() {
            const res = await fetch('/api/professions');
            const data = await res.json();
            const sel = document.getElementById('profession');
            sel.innerHTML = '<option value="">Any</option>';
            data.professions.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p; opt.textContent = p; sel.appendChild(opt);
            });
        }

        async function loadSpecsFor(prof) {
            const specSel = document.getElementById('spec');
            specSel.innerHTML = '<option value="">Any</option>';
            if (!prof) return;
            const res = await fetch(`/api/specs?profession=${encodeURIComponent(prof)}`);
            const data = await res.json();
            (data.specs || []).forEach(s => { const opt = document.createElement('option'); opt.value = s; opt.textContent = s; specSel.appendChild(opt); });
        }

        const _cache = new Map();
        function normalizeName(s){
            return (s||'').toLowerCase().replace(/["'`“”‘’!?.:,]/g,'').replace(/\s+/g,' ').trim();
        }
        async function fetchBySearch(collection, name) {
            const key = `${collection}|${name}`;
            if (_cache.has(key)) return _cache.get(key);
            const searchUrl = `https://api.guildwars2.com/v2/${collection}?search=${encodeURIComponent(name)}&lang=en`;
            const idsRes = await fetch(searchUrl);
            const ids = await idsRes.json();
            if (!Array.isArray(ids) || ids.length === 0) { _cache.set(key, []); return []; }
            const detailUrl = `https://api.guildwars2.com/v2/${collection}?ids=${ids.slice(0, 50).join(',')}&lang=en`;
            const detRes = await fetch(detailUrl);
            const details = await detRes.json();
            const arr = Array.isArray(details) ? details : [];
            _cache.set(key, arr);
            return arr;
        }

        async function fetchSkillIcon(name) {
            if (!name) return '';
            try {
                const details = await fetchBySearch('skills', name);
                if (!details.length) return '';
                const target = normalizeName(name);
                let match = details.find(s => normalizeName(s.name) === target);
                if (!match) match = details.find(s => normalizeName(s.name).includes(target));
                return (match?.icon || details[0]?.icon) || '';
            } catch { return ''; }
        }

        async function fetchSpecializationIcon(name) {
            if (!name) return '';
            try {
                const details = await fetchBySearch('specializations', name);
                if (!details.length) return '';
                const exact = details.find(s => s.name === name);
                return (exact?.icon || details[0]?.icon) || '';
            } catch { return ''; }
        }

        async function fetchSpecializationDetail(name) {
            try {
                const details = await fetchBySearch('specializations', name);
                if (!details.length) return null;
                return details.find(s => s.name === name) || details[0];
            } catch { return null; }
        }

        async function fetchTraitIcons(ids) {
            if (!ids.length) return [];
            const url = `https://api.guildwars2.com/v2/traits?ids=${ids.join(',')}&lang=en`;
            try { const res = await fetch(url); const data = await res.json(); return Array.isArray(data) ? data.map(t => t.icon || '') : []; } catch { return []; }
        }

        async function fetchPvpAmulets() {
            try { const res = await fetch('https://api.guildwars2.com/v2/pvp/amulets?ids=all&lang=en'); return await res.json(); } catch { return []; }
        }
        async function resolveAmuletIconFromText(text) {
            const m = text.match(/^(.*?) Amulet, Rune of/i);
            if (!m) return '';
            const base = m[1].trim();
            const amulets = await fetchPvpAmulets();
            const targetName = `${base} Amulet`;
            const found = Array.isArray(amulets) ? amulets.find(a => a.name === targetName) : null;
            return found?.icon || '';
        }

        async function fetchWeaponIcon(weapon) {
            // No direct API for weapon icons; use static placeholders for now
            return '';
        }

        async function generate() {
            const profession = document.getElementById('profession').value;
            const spec = document.getElementById('spec').value;
            const goBtn = document.getElementById('go');
            goBtn.disabled = true; goBtn.textContent = 'Generating…';
            const params = new URLSearchParams();
            if (profession) params.set('profession', profession);
            if (spec) params.set('spec', spec);
            const res = await fetch(`/api/build?${params.toString()}`);
            const data = await res.json();
            // Show result area now that we have data
            document.getElementById('result').classList.remove('hidden');
            
            // Update subtitle with profession and specialization
            const subtitleEl = document.getElementById('build-subtitle');
            // Use the actual specialization from the server response if available, otherwise use the selected spec or 'Any'
            let specName = spec || 'Any';
            if (data.specializations && data.specializations.length > 0) {
                // If a specific spec was selected, use that, otherwise use the third specialization (elite spec) from the response
                if (spec) {
                    specName = spec;
                } else {
                    // When "any" is selected, the server returns the actual specializations used
                    // The third specialization (index 2) is the elite specialization
                    if (data.specializations.length >= 3) {
                        const eliteSpec = data.specializations[2];
                        // Use the isCore attribute from the server
                        specName = eliteSpec.isCore ? 'Core' : eliteSpec.name;
                    } else {
                        specName = 'Core';
                    }
                }
            }
            subtitleEl.textContent = `${data.profession || profession || 'Random'} - ${specName}`;
            
            // Show screenshot button
            document.getElementById('screenshot').style.display = '';

            // Build title from first line of text
            const buildName = (data.text || '').split('\n')[0]?.trim() || '';
            const titleElTop = document.getElementById('build-name');
            titleElTop.textContent = buildName;

            // Render chat link
            const chat = document.getElementById('chat');
            chat.textContent = data.chat_link || '';

            // Render skills row
            const skills = data.skills || [];
            const ids = ['heal','util1','util2','util3','elite'];
            // Clear build-title since we're not using it for profession name anymore
            document.getElementById('build-title').textContent = '';
            for (let i = 0; i < 5; i++) {
                const box = document.getElementById(ids[i]);
                box.innerHTML = '';
                box.style.display = '';
            }
            // Fetch icons in parallel
            // use server-provided icons first for accuracy, fallback to client search
            let icons = Array.isArray(data.skills_icons) ? data.skills_icons : [];
            if (icons.length !== skills.length) {
                icons = await Promise.all(skills.map(n => fetchSkillIcon(n)));
            }
            // Revenant: show only two legend icons
            if ((data.profession || '') === 'Revenant') {
                const legendsLine = (data.text || '').split('\n').find(line => /\s\/\s/.test(line) && !/Sigil of/.test(line)) || '';
                const parts = legendsLine.split('/').map(s => s.trim()).filter(Boolean);
                const legendIcons = Array.isArray(data.legend_icons) ? data.legend_icons : [];
                const boxes = [document.getElementById('heal'), document.getElementById('util1')];
                for (let i = 0; i < boxes.length; i++) {
                    boxes[i].innerHTML = '';
                    const img = document.createElement('img'); img.src = legendIcons[i] || ''; img.alt = parts[i] || ''; boxes[i].appendChild(img);
                }
                // hide remaining boxes
                for (let i = 2; i < ids.length; i++) document.getElementById(ids[i]).style.display = 'none';
            } else {
                for (let i = 0; i < 5; i++) {
                    const box = document.getElementById(ids[i]);
                    const name = skills[i] || '';
                    const icon = icons[i] || '';
                    if (icon) {
                        const img = document.createElement('img');
                        img.src = icon; img.alt = name; box.title = name; box.appendChild(img);
                    } else {
                        box.title = name;
                    }
                }
            }

            // Render specializations + trait choices
            const specsWrap = document.getElementById('specs');
            specsWrap.innerHTML = '';
            const specs = data.specializations || [];
                         for (const s of specs) {
                 const row = document.createElement('div'); row.className = 'spec';
                 const header = document.createElement('div'); header.className = 'spec-header';
                 const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.textContent = s.name || '';

                const triad = (s.traits || []).map(x => parseInt(x, 10));
                // Build 3x3 trait matrix using server-provided icons and descriptions; grey out non-selected
                const matrix = (s.trait_matrix || [["","",""],["","",""],["","",""]]);
                const grid = document.createElement('div'); grid.className = 'traits-grid';
                // Transpose: swap rows/columns for display
                for (let r = 0; r < 3; r++) {
                    const row = document.createElement('div'); row.className = 'traits-row';
                    for (let c = 0; c < 3; c++) {
                        const cell = document.createElement('div'); cell.className = 'cell';
                        const traitData = matrix[c] && matrix[c][r];
                        
                        // Handle both old string format and new object format
                        let iconSrc = '';
                        let traitName = '';
                        let traitDescription = '';
                        
                        if (typeof traitData === 'object' && traitData !== null) {
                            iconSrc = traitData.icon || '';
                            traitName = traitData.name || '';
                            traitDescription = traitData.description || '';
                        } else {
                            // Fallback for old format
                            iconSrc = traitData || '';
                        }
                        
                        if (iconSrc) {
                            const img = document.createElement('img'); 
                            img.src = iconSrc; 
                            cell.appendChild(img);
                        }
                        
                        // Remove any default title attribute that might interfere
                        cell.removeAttribute('title');
                        
                                                 // Add custom tooltip data attributes
                         if (traitName || traitDescription) {
                             // Clean up the text by removing angle brackets and their contents
                             let cleanTraitName = traitName.replace(/<[^>]*>/g, '').trim();
                             let cleanDescription = traitDescription.replace(/<[^>]*>/g, '').trim();
                             
                             let tooltipText = cleanTraitName;
                             if (cleanDescription) {
                                 tooltipText += '\n\n' + cleanDescription;
                             }
                             cell.setAttribute('data-tooltip', tooltipText);
                         }
                        
                                                 // Add hover event listener for tooltip functionality
                         cell.addEventListener('mouseenter', (e) => {
                            
                            // Remove any existing tooltip first
                            if (cell.tooltipElement) {
                                cell.tooltipElement.remove();
                            }
                            
                                                         // Create tooltip element
                             const tooltip = document.createElement('div');
                             tooltip.className = 'custom-tooltip';
                             
                             // Split the tooltip text to make the title bold
                             const tooltipText = cell.getAttribute('data-tooltip');
                             const parts = tooltipText.split('\n\n');
                             
                             if (parts.length > 1) {
                                 // Create bold title and normal description
                                 const title = document.createElement('div');
                                 title.style.fontWeight = 'bold';
                                 title.style.marginBottom = '8px';
                                 title.textContent = parts[0];
                                 
                                 const description = document.createElement('div');
                                 description.textContent = parts[1];
                                 
                                 tooltip.appendChild(title);
                                 tooltip.appendChild(description);
                             } else {
                                 // Just the title, make it bold
                                 tooltip.style.fontWeight = 'bold';
                                 tooltip.textContent = tooltipText;
                             }
                            
                            // Apply styles individually to ensure they work
                            tooltip.style.position = 'absolute';
                            tooltip.style.bottom = '100%';
                            tooltip.style.left = '50%';
                            tooltip.style.transform = 'translateX(-50%)';
                            tooltip.style.background = 'linear-gradient(135deg, rgba(36, 40, 59, 0.98), rgba(26, 27, 38, 0.98))';
                            tooltip.style.color = 'var(--text)';
                            tooltip.style.padding = '12px 16px';
                            tooltip.style.borderRadius = '12px';
                            tooltip.style.fontSize = '13px';
                            tooltip.style.lineHeight = '1.4';
                            tooltip.style.whiteSpace = 'pre-line';
                            tooltip.style.width = 'max-content';
                            tooltip.style.maxWidth = '300px';
                            tooltip.style.minWidth = '200px';
                            tooltip.style.zIndex = '9999';
                                                         tooltip.style.border = '1px solid rgba(122, 162, 247, 0.3)';
                            tooltip.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(122, 162, 247, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.1)';
                            tooltip.style.pointerEvents = 'none';
                            tooltip.style.marginBottom = '12px';
                            tooltip.style.backdropFilter = 'blur(10px)';
                            tooltip.style.fontWeight = '500';
                            tooltip.style.letterSpacing = '0.2px';
                            tooltip.style.wordWrap = 'break-word';
                            tooltip.style.overflowWrap = 'break-word';
                            tooltip.style.hyphens = 'auto';
                            
                                                         // Add tooltip to cell
                             cell.appendChild(tooltip);
                             cell.tooltipElement = tooltip;
                        });
                        
                                                 cell.addEventListener('mouseleave', () => {
                             // Remove tooltip when mouse leaves
                             if (cell.tooltipElement) {
                                 cell.tooltipElement.remove();
                                 cell.tooltipElement = null;
                             }
                         });
                        
                        const selected = triad[c] === (r+1);
                        cell.classList.add(selected ? 'on' : 'off');
                        row.appendChild(cell);
                    }
                    grid.appendChild(row);
                }

                                 const specIcon = s.icon || await fetchSpecializationIcon(s.name);
                 if (specIcon) { 
                     const img = document.createElement('img'); 
                     img.src = specIcon; 
                     img.alt = s.name; 
                     img.width = 56; 
                     img.height = 56; 
                     img.style.borderRadius = '12px'; 
                     header.appendChild(img); 
                 }
                 
                 header.appendChild(nameEl);
                 row.appendChild(header);
                 row.appendChild(grid);
                 specsWrap.appendChild(row);
            }

            // Render weapons line (names; icons could be added if we host assets)
            const weaponsWrap = document.getElementById('weapons');
            weaponsWrap.innerHTML = '';
            const weapons = data.weapons || [];
            const weaponSigils = data.weapon_sigils || [];
            for (let i = 0; i < weapons.length; i++) {
                const row = document.createElement('div'); row.className = 'weapon';
                const name = document.createElement('div'); name.textContent = weapons[i] || '';
                const sigils = document.createElement('div'); sigils.className = 'sigils';
                const set = weaponSigils[i] || [];
                for (const s of set) {
                    const sb = document.createElement('div'); sb.className = 'sigil';
                    if (s.icon) { const img = document.createElement('img'); img.src = s.icon; img.alt = s.name; sb.appendChild(img); }
                    const label = document.createElement('span'); label.textContent = s.name || ''; sb.appendChild(label);
                    sigils.appendChild(sb);
                }
                row.appendChild(name); row.appendChild(sigils);
                weaponsWrap.appendChild(row);
            }

                                       // Prefix/Amulet, Rune, and Relic (PvP) - moved to weapons section
              const prefixIcon = data.amulet_icon || await resolveAmuletIconFromText(data.text || '');
              if (prefixIcon) {
                  // Create amulet element to be added to weapons section
                  const amuletEl = document.createElement('div');
                  amuletEl.className = 'weapon';
                  amuletEl.style.alignItems = 'center';
                  amuletEl.style.gap = '8px';
                  
                  const img = document.createElement('img'); 
                  img.src = prefixIcon; 
                  img.alt = 'Amulet'; 
                  img.width = 48; 
                  img.height = 48; 
                  img.style.borderRadius = '12px';
                  
                                     const amuletContainer = document.createElement('div');
                   amuletContainer.style.display = 'flex';
                   amuletContainer.style.flexDirection = 'column';
                   amuletContainer.style.gap = '2px';
                   
                   const amuletName = document.createElement('div');
                   amuletName.textContent = data.amulet_name ? `${data.amulet_name} Amulet` : 'PvP Amulet';
                   amuletName.style.fontSize = '13px';
                   amuletName.style.color = 'var(--text)';
                   amuletName.style.fontWeight = '500';
                   
                   amuletContainer.appendChild(amuletName);
                  
                  amuletEl.appendChild(img);
                  amuletEl.appendChild(amuletContainer);
                  
                  // Add to weapons section
                  const weaponsWrap = document.getElementById('weapons');
                  weaponsWrap.appendChild(amuletEl);
              }
             
                           // Add rune and relic display
              if (data.rune_name || data.relic_name) {
                  const runeRelicEl = document.createElement('div');
                  runeRelicEl.className = 'weapon';
                  runeRelicEl.style.alignItems = 'center';
                  runeRelicEl.style.gap = '16px';
                  
                  if (data.rune_name) {
                      const runeContainer = document.createElement('div');
                      runeContainer.style.display = 'flex';
                      runeContainer.style.alignItems = 'center';
                      runeContainer.style.gap = '8px';
                      
                      if (data.rune_icon) {
                          const runeImg = document.createElement('img');
                          runeImg.src = data.rune_icon;
                          runeImg.alt = `Rune of ${data.rune_name}`;
                          runeImg.width = 32;
                          runeImg.height = 32;
                          runeImg.style.borderRadius = '8px';
                          runeContainer.appendChild(runeImg);
                      }
                      
                      const runeLabel = document.createElement('div');
                      runeLabel.textContent = `Rune of ${data.rune_name}`;
                      runeLabel.style.fontSize = '13px';
                      runeLabel.style.color = 'var(--muted)';
                      runeContainer.appendChild(runeLabel);
                      
                      runeRelicEl.appendChild(runeContainer);
                  }
                  
                  if (data.relic_name) {
                      const relicContainer = document.createElement('div');
                      relicContainer.style.display = 'flex';
                      relicContainer.style.alignItems = 'center';
                      relicContainer.style.gap = '8px';
                      
                      if (data.relic_icon) {
                          const relicImg = document.createElement('img');
                          relicImg.src = data.relic_icon;
                          relicImg.alt = `Relic of ${data.relic_name}`;
                          relicImg.width = 32;
                          relicImg.height = 32;
                          relicImg.style.borderRadius = '8px';
                          relicContainer.appendChild(relicImg);
                      }
                      
                      const relicLabel = document.createElement('div');
                      relicLabel.textContent = `Relic of ${data.relic_name}`;
                      relicLabel.style.fontSize = '13px';
                      relicLabel.style.color = 'var(--muted)';
                      relicContainer.appendChild(relicLabel);
                      
                      runeRelicEl.appendChild(relicContainer);
                  }
                  
                  // Add to weapons section
                  const weaponsWrap = document.getElementById('weapons');
                  weaponsWrap.appendChild(runeRelicEl);
              }

              

            // Done loading
            goBtn.disabled = false; goBtn.textContent = 'Generate';
        }

        function copyChat() {
            const text = document.getElementById('chat').textContent.trim();
            if (!text) return;
            navigator.clipboard.writeText(text);
        }

                 async function takeScreenshot() {
             try {
                 const buildCard = document.querySelector('#result .card');
                 if (!buildCard) return;
                 
                 // Use html2canvas if available, otherwise fallback to browser screenshot
                 if (typeof html2canvas !== 'undefined') {
                     const canvas = await html2canvas(buildCard, {
                         backgroundColor: '#1a1b26',
                         scale: 2,
                         useCORS: true,
                         allowTaint: true
                     });
                    
                    // Convert canvas to blob and copy to clipboard
                    canvas.toBlob(async (blob) => {
                        try {
                            const clipboardItem = new ClipboardItem({
                                'image/png': blob
                            });
                            await navigator.clipboard.write([clipboardItem]);
                            
                            // Show success feedback
                            const btn = document.getElementById('screenshot');
                            const originalText = btn.textContent;
                            btn.textContent = '✅ Copied!';
                            btn.style.background = 'linear-gradient(45deg, var(--success), #9ece6a)';
                            btn.style.color = 'white';
                            btn.style.borderColor = 'var(--success)';
                            
                            setTimeout(() => {
                                btn.textContent = originalText;
                                btn.style.background = '';
                                btn.style.color = '';
                                btn.style.borderColor = '';
                            }, 2000);
                        } catch (clipboardError) {
                            console.error('Clipboard write failed:', clipboardError);
                            // Fallback to download if clipboard fails
                            const link = document.createElement('a');
                            link.download = `gw2-build-${Date.now()}.png`;
                            link.href = canvas.toDataURL();
                            link.click();
                        }
                    }, 'image/png');
                } else {
                    // Fallback: try to use browser's native screenshot API
                    if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                        const stream = await navigator.mediaDevices.getDisplayMedia({
                            preferCurrentTab: true
                        });
                        const track = stream.getVideoTracks()[0];
                        const imageCapture = new ImageCapture(track);
                        const bitmap = await imageCapture.grabFrame();
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = bitmap.width;
                        canvas.height = bitmap.height;
                        const context = canvas.getContext('2d');
                        context.drawImage(bitmap, 0, 0);
                        
                        // Try to copy to clipboard first
                        try {
                            canvas.toBlob(async (blob) => {
                                const clipboardItem = new ClipboardItem({
                                    'image/png': blob
                                });
                                await navigator.clipboard.write([clipboardItem]);
                            });
                        } catch (clipboardError) {
                            // Fallback to download
                            const link = document.createElement('a');
                            link.download = `gw2-build-${Date.now()}.png`;
                            link.href = canvas.toDataURL();
                            link.click();
                        }
                        
                        track.stop();
                    } else {
                        alert('Screenshot not supported in this browser. Try using browser dev tools or a screenshot extension.');
                    }
                }
            } catch (error) {
                console.error('Screenshot failed:', error);
                alert('Screenshot failed. Try using browser dev tools or a screenshot extension.');
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadProfessions();
            document.getElementById('go').addEventListener('click', generate);
            document.getElementById('copy').addEventListener('click', copyChat);
            document.getElementById('screenshot').addEventListener('click', takeScreenshot);
            const specWrap = document.getElementById('spec-wrap');
            specWrap.classList.add('hidden');
            document.getElementById('profession').addEventListener('change', async (e)=> {
                const val = e.target.value;
                if (!val) { specWrap.classList.add('hidden'); document.getElementById('spec').innerHTML = '<option value="">Any</option>'; return; }
                specWrap.classList.remove('hidden');
                await loadSpecsFor(val);
            });
        });
    </script>
</head>
<body>
    <div class="container">
        <h1>GW2 Random Build Generator</h1>
        <div class="controls">
            <label>Profession
                <select id="profession"></select>
            </label>
            <label id="spec-wrap">Spec
                <select id="spec"></select>
            </label>
            <button id="go" class="primary" data-tooltip="Generate a random build">Generate</button>
            <button id="screenshot" class="ghost" style="display: none;">📸 Copy Screenshot</button>
        </div>

        <div id="result" class="grid hidden">
            <div class="card stack">
                <div id="build-name" class="title">&nbsp;</div>
                <div id="build-subtitle" class="meta" style="margin-bottom: 16px; font-size: 16px; color: var(--accent); font-weight: 600; text-shadow: 0 0 10px rgba(122, 162, 247, 0.5);">&nbsp;</div>
                <div class="row between">
                    <div id="build-title" class="meta">&nbsp;</div>
                    <div class="row">
                        <div class="copy" id="chat">&nbsp;</div>
                        <button id="copy" class="ghost">Copy</button>
                    </div>
                </div>
                <div class="skillbar">
                    <div id="heal" class="skill" title=""></div>
                    <div id="util1" class="skill" title=""></div>
                    <div id="util2" class="skill" title=""></div>
                    <div id="util3" class="skill" title=""></div>
                    <div id="elite" class="skill" title=""></div>
                </div>
                <div class="row between">
                    <div class="weapons" id="weapons"></div>
                </div>
                <div class="specs" id="specs"></div>
            </div>
            <div class="stack">
                <!-- Placeholder for future: traits, weapons, gear visuals -->
            </div>
        </div>
    </div>
</body>
</html>


